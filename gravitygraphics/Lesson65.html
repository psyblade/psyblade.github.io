<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"> 
<meta http-equiv='cache-control' content='no-cache'>
<meta http-equiv='expires' content='0'>
<meta http-equiv='pragma' content='no-cache'>
<link href="../css/lessons.css" rel="stylesheet">
<script src="../lib/JQuery/jquery-3.6.0.min.js"></script>
<script src="../js/lessons.js"></script>
</head>
<body>
<div id="lesson" class="lesson">
	<h1>Lesson 65: Animation Loop</h1>
	<p><b>while(true) loop</b> is simple to implement and understand but highly inefficient, causing potential browser freezes and excessive CPU usage. Not suitable for animations in a browser environment.</p>
	<p><b>requestAnimationFrame(animate)</b> syncs with the browser's refresh rate, offering smoother animations and better resource management, though it requires understanding callbacks. The correct way to create animations in the browser. It also reducing workload when the tab is inactive.</p>
<pre>
// Animation loop
function animate() {
    drawSomething();
    requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</pre>

	<br><br>
	<h3></h3>
	<div id="buttons">
		<button class="buttonPreviousLesson" onclick="NavigateTo('Lesson64x4');">Exercise</button>
		<button class="buttonNextLesson" onclick="NavigateTo('Lesson66');">Lesson 66</button>
	</div>
</div>

<textarea id="LessonRunCode">
gr();
print ("Use W, A, S, D, to move the pixel");

let x = 0;
let y = 0;
let color = 1; // Assuming 1 represents blue in your palette
let moveX = 0;
let moveY = 0;

// Function to update the pixel's position based on the current movement direction
function updatePosition() {
    x += moveX;
    y += moveY;
    plot(x, y, color);  // Plot the pixel at the new position
    requestAnimationFrame(updatePosition);  // Call updatePosition again for the next frame
}

// Event listeners for keydown to set movement direction
document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case 'w': // Move up
            moveX = 0;
            moveY = -1;
            break;
        case 'a': // Move left
            moveX = -1;
            moveY = 0;
            break;
        case 's': // Move down
            moveX = 0;
            moveY = 1;
            break;
        case 'd': // Move right
            moveX = 1;
            moveY = 0;
            break;
    }
});

// No keyup event needed to stop movement, so the pixel keeps moving

// Start the animation
requestAnimationFrame(updatePosition);

// Initial plot of the blue pixel
plot(x, y, color);
</textarea>
<textarea id="LessonExampleCode">
gr();
print ("Use W, A, S, D, to move the pixel");

let x = 0;
let y = 0;
let color = 1; // Assuming 1 represents blue in your palette
let moveX = 0;
let moveY = 0;

// Function to update the pixel's position based on the current movement direction
function updatePosition() {
    x += moveX;
    y += moveY;
    plot(x, y, color);  // Plot the pixel at the new position
    requestAnimationFrame(updatePosition);  // Call updatePosition again for the next frame
}

// Event listeners for keydown to set movement direction
document.addEventListener('keydown', (event) => {
    switch (event.key) {
        case 'w': // Move up
            moveX = 0;
            moveY = -1;
            break;
        case 'a': // Move left
            moveX = -1;
            moveY = 0;
            break;
        case 's': // Move down
            moveX = 0;
            moveY = 1;
            break;
        case 'd': // Move right
            moveX = 1;
            moveY = 0;
            break;
    }
});

// No keyup event needed to stop movement, so the pixel keeps moving

// Start the animation
requestAnimationFrame(updatePosition);

// Initial plot of the blue pixel
plot(x, y, color);
</textarea>
<script>
parent.ShowExample();
parent.LoadYourCode("TextAreaYourCode", "Lesson65");
parent.HideHelper();
parent.HideHelperButton();
</script>
</body>
</html>